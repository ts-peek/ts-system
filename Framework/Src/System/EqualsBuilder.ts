/// <reference path="../reference.ts"/>

module System {
    "use strict";

    import Contract = Diagnosis.Contract;

    /**
     * Class providing means to implement the <code>Object::equals</code> method in a concise and consistent way.
     * This class is consistend with the <code>HashCodeBuilder</code> class, so that equal objects are guaranteed to 
     * return the same hash code value.
     * 
     * @author Christian Schaiter
     * @see HashCodeBuilder
     */
    export class EqualsBuilder {

        private equal: boolean = true;

        /**
         * Tests if two values are equal, considering the special behavior of the values's type.
         * @param first The first value to compare.
         * @param second The second value to compare.
         * @return This <code>EqualsBuilder</code> instance, which may be used for chaining.
         */
        public append(first: any, second: any): EqualsBuilder {
            if (!this.equal) {
                return this;
            }

            this.equal = ObjectUtil.areEqual(first, second);
            return this;
        }

        /**
         * Adds the result of <code>super.equals(object)</code> to this builder.
         * <p>
         * Always call <code>appendBase</code> if the class that uses this <code>EqualsBuilder</code> for the
         * implementation of its <code>Object::equals</code> method inherits from some superclass. This ensures
         * that all properties of the superclass are conviniently incorporated into the final result of the 
         * <code>equals</code> method. Accordingly, only the own properties (used for the <code>equals</code> and 
         * <code>hashCode</code> methods) of the class must be appended. This means that each class may concentrate on
         * their own properties.
         * @param baseEquals The result when calling <code>super.equals(object)</code>.
         * @return This <code>EqualsBuilder</code> instance, which may be used for chaining.
         */
        public appendBase(baseEquals: boolean): EqualsBuilder {
            if (!this.equal) {
                return this;
            }

            if (!baseEquals) {
                baseEquals = false;
            }

            this.equal = baseEquals;
            return this;
        }

        /**
         * Tests if two boolean values are equal.
         * @param first The first boolean value to compare.
         * @param second The second boolean value to compare.
         * @return This <code>EqualsBuilder</code> instance, which may be used for chaining.
         */
        public appendBoolean(first: boolean, second: boolean): EqualsBuilder {
            if (!this.equal) {
                return this;
            }

            this.equal = first === second;
            return this;
        }

        /**
         * Tests if two numbers are equal, optionally using a the number of precision digits.
         * This method is compatible with the hash code generated by <code>HashCodeBuilder</code> when being invoked 
         * with the same value for <code>precisionDigits</code>.
         * @param first The first number to compare.
         * @param second The second number to compare.
         * @param precisionDigits The number of decimal digits that must be zero in the absolute difference 
         * <code>|first - second|</code> in order to be considered as equal. If <code>precisionDigits</code> is zero, 
         * the two numbers must match exactly to be treated as equal. Must be non-negative. Defaults to 0.
         * @return This <code>EqualsBuilder</code> instance, which may be used for chaining.
         * @throws <code>ArgumentOutOfRangeException</code> If the <code>precisionDigits</code> argument is negative.
         */
        public appendNumber(first: number, second: number, precisionDigits: number = 0): EqualsBuilder {
            Contract.isInRange(precisionDigits, 0, Number.POSITIVE_INFINITY,
                "Argument @precisionDigits must not be negative.");

            if (!this.equal) {
                return this;
            }

            this.equal = NumberUtil.equalsNDigitsPrecision(first, second, precisionDigits);
            return this;
        }

        /**
         * Tests if two objects are equal.
         * @param first The first object to compare.
         * @param second The second object to compare.
         * @return This <code>EqualsBuilder</code> instance, which may be used for chaining.
         */
        public appendObject(first: Object, second: Object): EqualsBuilder {
            if (!this.equal) {
                return this;
            }

            this.equal = ObjectUtil.areEqual(first, second);
            return this;
        }

        /**
         * Tests if two strings are equal in a strict manner, i.e. <code>undefined</code>, <code>null</code> and empty
         * <code>string</code> values are considered NOT equal.
         * @param first The first string to compare.
         * @param second The second string to compare.
         * @param strategy The strategy to use when comparing the two strings. If this parameter is not provided, 
         * <code>StringComparison::ORDINAL</code> will be used.
         * @return This <code>EqualsBuilder</code> instance, which may be used for chaining.
         */
        public appendString(first: string, second: string, strategy: StringComparison = StringComparison.ORDINAL): EqualsBuilder {
            if (!this.equal) {
                return this;
            } else if (!ObjectUtil.isDefined(first) || !ObjectUtil.isDefined(second)) {
                this.equal = first === second;
                return this;
            }

            return this.appendStringRelaxed(first, second, strategy);
        }

        /**
         * Tests if two strings are equal in a relaxed manner, i.e. undefined, null and empty string values are
         * considered equal.
         * @param first The first string to compare.
         * @param second The second string to compare.
         * @param strategy The strategy to use when comparing the two strings. If this parameter is not provided, 
         * <code>StringComparison::ORDINAL</code> will be used.
         * @return This <code>EqualsBuilder</code> instance, which may be used for chaining.
         */
        public appendStringRelaxed(first: string, second: string, strategy: StringComparison = StringComparison.ORDINAL): EqualsBuilder {
            if (!this.equal) {
                return this;
            } else if (!first && !second) {
                // if both strings are falsy values (undefined, null, empty string), they are considered equal
                this.equal = true;
                return this;
            }

            this.equal = strategy === StringComparison.IGNORE_CASE
                ? first.toUpperCase() === second.toUpperCase()
                : first === second;

            return this;
        }

        /**
         * Gets whether or not all tested objects are equal.
         * @return <code>true</code> if all tested objects are equal, <code>false</code> otherwise.
         */
        public isEqual(): boolean {
            return this.equal;
        }
    }
}